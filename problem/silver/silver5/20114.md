# 미아 노트

- 시간 제한 : 1s
- 메모리 제한 : 256MB

### 문제

미아는 과일을 좋아하는 소녀이다. 그녀의 비밀 노트에는 과일에 대해 그녀가 수집한 정보들이 가득하다.

평소와 다를 바 없이 과일들을 잔뜩 관찰하고 기쁜 마음으로 하교하던 어느 날, 친구가 뒤에서 덮치는 바람에 실수로 비밀 노트를 물에 빠뜨리고 말았다.

다행히 노트는 건질 수 있었지만, 노트에 적어두었던 정보들이 번지고 지워져버려 일부는 알아볼 수 없게 되었다.

노트에 적힌 문자열이 번진 패턴은 일정했는데, 가령 "abc" 문자가 세로로 3글자씩, 가로로 2글자씩 번진 경우는 다음과 같았다.

```
aabbcc
aabbcc
aabbcc
```
이 패턴을 이용해 문자열을 완전히 복원할 수 있을 것 같았지만, 아쉽게도 번진 문자열의 일부는 지워진 상태였다.<br>
너무 많이 지워져버려서 해당 자리의 문자를 유추할 수 없는 경우, 완전히 문자열을 복원하지 못할 수도 있다.

미아는 자신이 아끼는 노트가 물에 빠진 바람에 매우 속상해하고 있다. 문자열을 최대한 완전히 복원해서 미아의 기를 살려주자!


### 입력

첫째 줄에 원래 문자열의 길이 N, 세로로 번진 글자의 개수 H, 가로로 번진 글자의 개수 W가 주어진다. (1 ≤ N ≤ 100, 1 ≤ H ≤ 10, 1 ≤ W ≤ 10)

둘째 줄부터 H개의 줄에 걸쳐 N × W 길이의 문자열이 주어진다. 문자열은 알파벳 소문자 또는 '?'로만 이루어져 있다. '?'는 해당 자리의 문자가 지워진 경우를 뜻한다.

문자가 번진 자리에 두 개 이상의 문자가 있는 등 모순되는 경우는 입력으로 주어지지 않는다.


### 출력

손상되기 전의 원래 문자열을 출력한다. 복원할 수 없는 문자는 '?'로 출력한다.


### 예제
```
3 2 2
a?????
???bcc
```
`abc`

```
6 2 3
???rrruuu???ttt???
f?f?rruuu?????t???
```
`fru?t?`

---
## 풀이

### 접근 방식

최대 길이라고 해도 10000이라서 O(n^2)이라도 아슬하게 걸칠 거 같아서 했는데 해봤는데 맞았다.

str은 인덱스로 수정할 수 없어서 답을 애초에 list로 n만큼 ?로 채웠다.

그리고 번진 횟수만큼 나눠서 만약 "?"가 아니라면 답을 채우는 방식


### 코드

```python
n, h, w = map(int, input().split())
word = list(input() for _ in range(h))

answer = ['?' for i in range(n)]

for i in range(h):
    for j in range(n*w):
        if word[i][j] == '?':
            continue
        else:
            answer[j//w]=word[i][j]
print("".join(answer))
```

## 다른 사람 풀이

### 접근 방식

문자열, 구현 유형의 문제

원래의 문자열의 길이만큼 반복하면서 해당 문자열의 위치(변수 x) 부터 번진만큼 반복문을 통해 원래 문자를 찾는다.

원래 문자열의 위치 x부터 가로로 번진만큼 반복하고, 세로로 번진만큼 또 반복을 하면서 원래 문자열을 지금 찾을 수 있는지 알아본다.

ans에 문자열을 찾을 수 있다면 찾은 해당 문자열을 넣고, 아니라면 ? 를 넣는다.

### 코드

```python
from sys import stdin

n, h, w = map(int, stdin.readline().split())
arr = [list(stdin.readline().rstrip()) for _ in range(h)]


def solve(x):
    global ans
    for i in range(x * w, (x + 1) * w):
        for j in range(h):
            if arr[j][i] != '?':
                ans += arr[j][i]
                return
    ans += '?'
    return


ans = ''
for i in range(n):
    solve(i)
print(ans)
```

푸는 방식은 그냥 비슷한 듯